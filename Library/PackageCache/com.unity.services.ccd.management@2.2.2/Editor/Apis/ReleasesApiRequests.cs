//-----------------------------------------------------------------------------
// <auto-generated>
//     This file was generated by the C# SDK Code Generator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//-----------------------------------------------------------------------------


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using UnityEngine;
using UnityEngine.Networking;
using UnityEngine.Scripting;
using Unity.Services.Ccd.Management.Models;
using Unity.Services.Ccd.Management.Scheduler;


namespace Unity.Services.Ccd.Management.Releases
{
    internal static class JsonSerialization
    {
        public static byte[] Serialize<T>(T obj)
        {
            return Encoding.UTF8.GetBytes(SerializeToString(obj));
        }

        public static string SerializeToString<T>(T obj)
        {
            return JsonConvert.SerializeObject(obj, new JsonSerializerSettings{ReferenceLoopHandling = Newtonsoft.Json.ReferenceLoopHandling.Ignore});
        }
    }

    /// <summary>
    /// ReleasesApiBaseRequest class
    /// </summary>
    [Preserve]
    internal class ReleasesApiBaseRequest
    {
        /// <summary>
        /// Helper function to add a provided key and value to the provided
        /// query params and to escape the values correctly if it is a URL.
        /// </summary>
        /// <param name="queryParams">A `List/<string/>` of the query parameters.</param>
        /// <param name="key">The key to be added.</param>
        /// <param name="value">The value to be added.</param>
        /// <returns>Returns a `List/<string/>` with the `key` and `value` added to the provided `queryParams`.</returns>
        [Preserve]
        public List<string> AddParamsToQueryParams(List<string> queryParams, string key, string value)
        {
            key = UnityWebRequest.EscapeURL(key);
            value = UnityWebRequest.EscapeURL(value);
            queryParams.Add($"{key}={value}");

            return queryParams;
        }

        /// <summary>
        /// Helper function to add a provided key and list of values to the
        /// provided query params and to escape the values correctly if it is a
        /// URL.
        /// </summary>
        /// <param name="queryParams">A `List/<string/>` of the query parameters.</param>
        /// <param name="key">The key to be added.</param>
        /// <param name="values">List of values to be added.</param>
        /// <param name="style">string for defining the style, currently unused.</param>
        /// <param name="explode">True if query params should be escaped and added separately.</param>
        /// <returns>Returns a `List/<string/>`</returns>
        [Preserve]
        public List<string> AddParamsToQueryParams(List<string> queryParams, string key, List<string> values, string style, bool explode)
        {
            if (explode)
            {
                foreach(var value in values)
                {
                    string escapedValue = UnityWebRequest.EscapeURL(value);
                    queryParams.Add($"{UnityWebRequest.EscapeURL(key)}={escapedValue}");
                }
            }
            else
            {
                string paramString = $"{UnityWebRequest.EscapeURL(key)}=";
                foreach(var value in values)
                {
                    paramString += UnityWebRequest.EscapeURL(value) + ",";
                }
                paramString = paramString.Remove(paramString.Length - 1);
                queryParams.Add(paramString);
            }

            return queryParams;
        }

        /// <summary>
        /// Helper function to add a provided map of keys and values, representing a model, to the
        /// provided query params.
        /// </summary>
        /// <param name="queryParams">A `List/<string/>` of the query parameters.</param>
        /// <param name="modelVars">A `Dictionary` representing the vars of the model</param>
        /// <returns>Returns a `List/<string/>`</returns>
        [Preserve]
        public List<string> AddParamsToQueryParams(List<string> queryParams, Dictionary<string, string> modelVars)
        {
            foreach(var key in modelVars.Keys)
            {
                string escapedValue = UnityWebRequest.EscapeURL(modelVars[key]);
                queryParams.Add($"{UnityWebRequest.EscapeURL(key)}={escapedValue}");
            }

            return queryParams;
        }

        /// <summary>
        /// Helper function to add a provided key and value to the provided
        /// query params and to escape the values correctly if it is a URL.
        /// </summary>
        /// <param name="queryParams">A `List/<string/>` of the query parameters.</param>
        /// <param name="key">The key to be added.</param>
        /// <typeparam name="T">The type of the value to be added.</typeparam>
        /// <param name="value">The value to be added.</param>
        /// <returns>Returns a `List/<string/>`</returns>
        [Preserve]
        public List<string> AddParamsToQueryParams<T>(List<string> queryParams, string key, T value)
        {
            if (queryParams == null)
            {
                queryParams = new List<string>();
            }

            key = UnityWebRequest.EscapeURL(key);
            string valueString = UnityWebRequest.EscapeURL(value.ToString());
            queryParams.Add($"{key}={valueString}");
            return queryParams;
        }

        /// <summary>
        /// Constructs a string representing an array path parameter.
        /// </summary>
        /// <param name="pathParam">The list of values to convert to string.</param>
        /// <returns>String representing the param.</returns>
        [Preserve]
        public string GetPathParamString(List<string> pathParam)
        {
            string paramString = "";
            foreach(var value in pathParam)
            {
                paramString += UnityWebRequest.EscapeURL(value) + ",";
            }
            paramString = paramString.Remove(paramString.Length - 1);
            return paramString;
        }

        /// <summary>
        /// Constructs the body of the request based on IO stream.
        /// </summary>
        /// <param name="stream">The IO stream to use.</param>
        /// <returns>Byte array representing the body.</returns>
        public byte[] ConstructBody(System.IO.Stream stream)
        {
            if (stream != null)
            {
                using (System.IO.MemoryStream ms = new System.IO.MemoryStream())
                {
                    stream.CopyTo(ms);
                    return ms.ToArray();
                }
            }
            return null;
        }

        /// <summary>
        /// Construct the request body based on string value.
        /// </summary>
        /// <param name="s">The input body.</param>
        /// <returns>Byte array representing the body.</returns>
        public byte[] ConstructBody(string s)
        {
            return System.Text.Encoding.UTF8.GetBytes(s);
        }

        /// <summary>
        /// Construct request body based on generic object.
        /// </summary>
        /// <param name="o">The object to use.</param>
        /// <returns>Byte array representing the body.</returns>
        public byte[] ConstructBody(object o)
        {
            return JsonSerialization.Serialize(o);
        }

        /// <summary>
        /// Generate an accept header.
        /// </summary>
        /// <param name="accepts">list of accepts objects.</param>
        /// <returns>The generated accept header.</returns>
        public string GenerateAcceptHeader(string[] accepts)
        {
            if (accepts.Length == 0)
            {
                return null;
            }
            for (int i = 0; i < accepts.Length; ++i)
            {
                if (string.Equals(accepts[i], "application/json", System.StringComparison.OrdinalIgnoreCase))
                {
                    return "application/json";
                }
            }
            return string.Join(", ", accepts);
        }

        private static readonly Regex JsonRegex = new Regex(@"application\/json(;\s)?((charset=utf8|q=[0-1]\.\d)(\s)?)*");

        /// <summary>
        /// Generate Content Type Header.
        /// </summary>
        /// <param name="contentTypes">The content types.</param>
        /// <returns>The Content Type Header.</returns>
        public string GenerateContentTypeHeader(string[] contentTypes)
        {
            if (contentTypes.Length == 0)
            {
                return null;
            }

            for(int i = 0; i < contentTypes.Length; ++i)
            {
                if (!string.IsNullOrWhiteSpace(contentTypes[i]) && JsonRegex.IsMatch(contentTypes[i]))
                {
                    return contentTypes[i];
                }
            }
            return contentTypes[0];
        }

        /// <summary>
        /// Generate multipart form file section.
        /// </summary>
        /// <param name="paramName">The parameter name.</param>
        /// <param name="stream">The file stream to use.</param>
        /// <param name="contentType">The content type.</param>
        /// <returns>Returns a multipart form section.</returns>
        public IMultipartFormSection GenerateMultipartFormFileSection(string paramName, System.IO.FileStream stream, string contentType)
        {
            return new MultipartFormFileSection(paramName, ConstructBody(stream), GetFileName(stream.Name), contentType);
        }

        /// <summary>
        /// Generate multipart form file section.
        /// </summary>
        /// <param name="paramName">The parameter name.</param>
        /// <param name="stream">The IO stream to use.</param>
        /// <param name="contentType">The content type.</param>
        /// <returns>Returns a multipart form section.</returns>
        public IMultipartFormSection GenerateMultipartFormFileSection(string paramName, System.IO.Stream stream, string contentType)
        {
            return new MultipartFormFileSection(paramName, ConstructBody(stream), Guid.NewGuid().ToString(), contentType);
        }

        private string GetFileName(string filePath)
        {
            return System.IO.Path.GetFileName(filePath);
        }
    }

    /// <summary>
    /// CreateReleaseRequest
    /// Create release
    /// </summary>
    [Preserve]
    internal class CreateReleaseRequest : ReleasesApiBaseRequest
    {
        /// <summary>Accessor for bucketid </summary>
        [Preserve]
        public string Bucketid { get; }
        /// <summary>Accessor for projectid </summary>
        [Preserve]
        public string Projectid { get; }
        /// <summary>Accessor for ccdReleaseCreate </summary>
        [Preserve]
        public Unity.Services.Ccd.Management.Models.CcdReleaseCreate CcdReleaseCreate { get; }
        string PathAndQueryParams;

        /// <summary>
        /// CreateRelease Request Object.
        /// Create release
        /// </summary>
        /// <param name="bucketid">Bucket ID</param>
        /// <param name="projectid">Project ID</param>
        /// <param name="ccdReleaseCreate">Release</param>
        [Preserve]
        public CreateReleaseRequest(string bucketid, string projectid, Unity.Services.Ccd.Management.Models.CcdReleaseCreate ccdReleaseCreate)
        {
            Bucketid = bucketid;

            Projectid = projectid;

            CcdReleaseCreate = ccdReleaseCreate;
            PathAndQueryParams = $"/api/ccd/management/v1/projects/{projectid}/buckets/{bucketid}/releases";


        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return ConstructBody(CcdReleaseCreate);
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
                "application/json"
            };

            string[] accepts = {
                "application/json",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "POST";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// CreateReleaseEnvRequest
    /// Create release
    /// </summary>
    [Preserve]
    internal class CreateReleaseEnvRequest : ReleasesApiBaseRequest
    {
        /// <summary>Accessor for environmentid </summary>
        [Preserve]
        public string Environmentid { get; }
        /// <summary>Accessor for bucketid </summary>
        [Preserve]
        public string Bucketid { get; }
        /// <summary>Accessor for projectid </summary>
        [Preserve]
        public string Projectid { get; }
        /// <summary>Accessor for ccdReleaseCreate </summary>
        [Preserve]
        public Unity.Services.Ccd.Management.Models.CcdReleaseCreate CcdReleaseCreate { get; }
        string PathAndQueryParams;

        /// <summary>
        /// CreateReleaseEnv Request Object.
        /// Create release
        /// </summary>
        /// <param name="environmentid">Environment ID</param>
        /// <param name="bucketid">Bucket ID</param>
        /// <param name="projectid">Project ID</param>
        /// <param name="ccdReleaseCreate">Release</param>
        [Preserve]
        public CreateReleaseEnvRequest(string environmentid, string bucketid, string projectid, Unity.Services.Ccd.Management.Models.CcdReleaseCreate ccdReleaseCreate)
        {
            Environmentid = environmentid;

            Bucketid = bucketid;

            Projectid = projectid;

            CcdReleaseCreate = ccdReleaseCreate;
            PathAndQueryParams = $"/api/ccd/management/v1/projects/{projectid}/environments/{environmentid}/buckets/{bucketid}/releases";


        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return ConstructBody(CcdReleaseCreate);
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
                "application/json"
            };

            string[] accepts = {
                "application/json",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "POST";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// GetErrorDetailsRequest
    /// Get detail error information
    /// </summary>
    [Preserve]
    internal class GetErrorDetailsRequest : ReleasesApiBaseRequest
    {
        /// <summary>Accessor for bucketid </summary>
        [Preserve]
        public string Bucketid { get; }
        /// <summary>Accessor for releaseid </summary>
        [Preserve]
        public string Releaseid { get; }
        /// <summary>Accessor for interval </summary>
        [Preserve]
        public string Interval { get; }
        /// <summary>Accessor for projectid </summary>
        [Preserve]
        public string Projectid { get; }
        /// <summary>Accessor for perPage </summary>
        [Preserve]
        public int? PerPage { get; }
        string PathAndQueryParams;

        /// <summary>
        /// GetErrorDetails Request Object.
        /// Get detail error information
        /// </summary>
        /// <param name="bucketid">Bucket ID</param>
        /// <param name="releaseid">Release ID</param>
        /// <param name="interval">Select the time interval for which you want the stats. day indicates last 24 hrs week indicates last 7 days month indicates last 30 days </param>
        /// <param name="projectid">Project ID</param>
        /// <param name="perPage">Items Per Page</param>
        [Preserve]
        public GetErrorDetailsRequest(string bucketid, string releaseid, string interval, string projectid, int? perPage = 10)
        {
            Bucketid = bucketid;

            Releaseid = releaseid;

            Interval = interval;
            Projectid = projectid;

            PerPage = perPage;
            PathAndQueryParams = $"/api/ccd/management/v1/projects/{projectid}/buckets/{bucketid}/releases/{releaseid}/stats/details/errors";

            List<string> queryParams = new List<string>();

            var perPageStringValue = PerPage.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "per_page", perPageStringValue);
            if(!string.IsNullOrEmpty(Interval))
            {
                queryParams = AddParamsToQueryParams(queryParams, "interval", Interval);
            }
            if (queryParams.Count > 0)
            {
                PathAndQueryParams = $"{PathAndQueryParams}?{string.Join("&", queryParams)}";
            }
        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
            };

            string[] accepts = {
                "text/csv",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "GET";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// GetErrorDetailsEnvRequest
    /// Get detail error information
    /// </summary>
    [Preserve]
    internal class GetErrorDetailsEnvRequest : ReleasesApiBaseRequest
    {
        /// <summary>Accessor for environmentid </summary>
        [Preserve]
        public string Environmentid { get; }
        /// <summary>Accessor for bucketid </summary>
        [Preserve]
        public string Bucketid { get; }
        /// <summary>Accessor for releaseid </summary>
        [Preserve]
        public string Releaseid { get; }
        /// <summary>Accessor for interval </summary>
        [Preserve]
        public string Interval { get; }
        /// <summary>Accessor for projectid </summary>
        [Preserve]
        public string Projectid { get; }
        /// <summary>Accessor for perPage </summary>
        [Preserve]
        public int? PerPage { get; }
        string PathAndQueryParams;

        /// <summary>
        /// GetErrorDetailsEnv Request Object.
        /// Get detail error information
        /// </summary>
        /// <param name="environmentid">Environment ID</param>
        /// <param name="bucketid">Bucket ID</param>
        /// <param name="releaseid">Release ID</param>
        /// <param name="interval">Select the time interval for which you want the stats. day indicates last 24 hrs week indicates last 7 days month indicates last 30 days </param>
        /// <param name="projectid">Project ID</param>
        /// <param name="perPage">Items Per Page</param>
        [Preserve]
        public GetErrorDetailsEnvRequest(string environmentid, string bucketid, string releaseid, string interval, string projectid, int? perPage = 10)
        {
            Environmentid = environmentid;

            Bucketid = bucketid;

            Releaseid = releaseid;

            Interval = interval;
            Projectid = projectid;

            PerPage = perPage;
            PathAndQueryParams = $"/api/ccd/management/v1/projects/{projectid}/environments/{environmentid}/buckets/{bucketid}/releases/{releaseid}/stats/details/errors";

            List<string> queryParams = new List<string>();

            var perPageStringValue = PerPage.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "per_page", perPageStringValue);
            if(!string.IsNullOrEmpty(Interval))
            {
                queryParams = AddParamsToQueryParams(queryParams, "interval", Interval);
            }
            if (queryParams.Count > 0)
            {
                PathAndQueryParams = $"{PathAndQueryParams}?{string.Join("&", queryParams)}";
            }
        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
            };

            string[] accepts = {
                "text/csv",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "GET";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// GetReleaseRequest
    /// Get release
    /// </summary>
    [Preserve]
    internal class GetReleaseRequest : ReleasesApiBaseRequest
    {
        /// <summary>Accessor for bucketid </summary>
        [Preserve]
        public string Bucketid { get; }
        /// <summary>Accessor for releaseid </summary>
        [Preserve]
        public string Releaseid { get; }
        /// <summary>Accessor for projectid </summary>
        [Preserve]
        public string Projectid { get; }
        string PathAndQueryParams;

        /// <summary>
        /// GetRelease Request Object.
        /// Get release
        /// </summary>
        /// <param name="bucketid">Bucket ID</param>
        /// <param name="releaseid">Release ID</param>
        /// <param name="projectid">Project ID</param>
        [Preserve]
        public GetReleaseRequest(string bucketid, string releaseid, string projectid)
        {
            Bucketid = bucketid;

            Releaseid = releaseid;

            Projectid = projectid;

            PathAndQueryParams = $"/api/ccd/management/v1/projects/{projectid}/buckets/{bucketid}/releases/{releaseid}";


        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
            };

            string[] accepts = {
                "application/json",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "GET";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// GetReleaseByBadgeRequest
    /// Get release by badge
    /// </summary>
    [Preserve]
    internal class GetReleaseByBadgeRequest : ReleasesApiBaseRequest
    {
        /// <summary>Accessor for bucketid </summary>
        [Preserve]
        public string Bucketid { get; }
        /// <summary>Accessor for badgename </summary>
        [Preserve]
        public string Badgename { get; }
        /// <summary>Accessor for projectid </summary>
        [Preserve]
        public string Projectid { get; }
        string PathAndQueryParams;

        /// <summary>
        /// GetReleaseByBadge Request Object.
        /// Get release by badge
        /// </summary>
        /// <param name="bucketid">Bucket ID</param>
        /// <param name="badgename">Badge Name</param>
        /// <param name="projectid">Project ID</param>
        [Preserve]
        public GetReleaseByBadgeRequest(string bucketid, string badgename, string projectid)
        {
            Bucketid = bucketid;

            Badgename = badgename;

            Projectid = projectid;

            PathAndQueryParams = $"/api/ccd/management/v1/projects/{projectid}/buckets/{bucketid}/release_by_badge/{badgename}";


        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
            };

            string[] accepts = {
                "application/json",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "GET";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// GetReleaseByBadgeEnvRequest
    /// Get release by badge
    /// </summary>
    [Preserve]
    internal class GetReleaseByBadgeEnvRequest : ReleasesApiBaseRequest
    {
        /// <summary>Accessor for environmentid </summary>
        [Preserve]
        public string Environmentid { get; }
        /// <summary>Accessor for bucketid </summary>
        [Preserve]
        public string Bucketid { get; }
        /// <summary>Accessor for badgename </summary>
        [Preserve]
        public string Badgename { get; }
        /// <summary>Accessor for projectid </summary>
        [Preserve]
        public string Projectid { get; }
        string PathAndQueryParams;

        /// <summary>
        /// GetReleaseByBadgeEnv Request Object.
        /// Get release by badge
        /// </summary>
        /// <param name="environmentid">Environment ID</param>
        /// <param name="bucketid">Bucket ID</param>
        /// <param name="badgename">Badge Name</param>
        /// <param name="projectid">Project ID</param>
        [Preserve]
        public GetReleaseByBadgeEnvRequest(string environmentid, string bucketid, string badgename, string projectid)
        {
            Environmentid = environmentid;

            Bucketid = bucketid;

            Badgename = badgename;

            Projectid = projectid;

            PathAndQueryParams = $"/api/ccd/management/v1/projects/{projectid}/environments/{environmentid}/buckets/{bucketid}/release_by_badge/{badgename}";


        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
            };

            string[] accepts = {
                "application/json",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "GET";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// GetReleaseDiffRequest
    /// Get counts of changes between releases
    /// </summary>
    [Preserve]
    internal class GetReleaseDiffRequest : ReleasesApiBaseRequest
    {
        /// <summary>Accessor for bucketid </summary>
        [Preserve]
        public string Bucketid { get; }
        /// <summary>Accessor for projectid </summary>
        [Preserve]
        public string Projectid { get; }
        /// <summary>Accessor for fromreleaseid </summary>
        [Preserve]
        public string Fromreleaseid { get; }
        /// <summary>Accessor for fromreleasenum </summary>
        [Preserve]
        public int? Fromreleasenum { get; }
        /// <summary>Accessor for toreleaseid </summary>
        [Preserve]
        public string Toreleaseid { get; }
        /// <summary>Accessor for toreleasenum </summary>
        [Preserve]
        public int? Toreleasenum { get; }
        string PathAndQueryParams;

        /// <summary>
        /// GetReleaseDiff Request Object.
        /// Get counts of changes between releases
        /// </summary>
        /// <param name="bucketid">Bucket ID</param>
        /// <param name="projectid">Project ID</param>
        /// <param name="fromreleaseid">From Release ID, specify 'latest' to use the most recent release. Either fromreleaseid or fromreleasenum can be specified, but not both. </param>
        /// <param name="fromreleasenum">From Release Number. To query against an empty bucket you may set fromreleasenum to zero. Either fromreleaseid or fromreleasenum can be specified, but not both. </param>
        /// <param name="toreleaseid">To Release ID, when not specified the most recent state of the bucket will be used. Either toreleaseid or toreleasenum can be specified, but not both. </param>
        /// <param name="toreleasenum">To Release ID, when not specified the most recent state of the bucket will be used. Either toreleaseid or toreleasenum can be specified, but not both. </param>
        [Preserve]
        public GetReleaseDiffRequest(string bucketid, string projectid, string fromreleaseid = default(string), int? fromreleasenum = default(int?), string toreleaseid = default(string), int? toreleasenum = default(int?))
        {
            Bucketid = bucketid;

            Projectid = projectid;

            Fromreleaseid = fromreleaseid;
            Fromreleasenum = fromreleasenum;
            Toreleaseid = toreleaseid;
            Toreleasenum = toreleasenum;
            PathAndQueryParams = $"/api/ccd/management/v1/projects/{projectid}/buckets/{bucketid}/diff/releases";

            List<string> queryParams = new List<string>();

            if(!string.IsNullOrEmpty(Fromreleaseid))
            {
                queryParams = AddParamsToQueryParams(queryParams, "fromreleaseid", Fromreleaseid);
            }
            var fromreleasenumStringValue = Fromreleasenum.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "fromreleasenum", fromreleasenumStringValue);
            if(!string.IsNullOrEmpty(Toreleaseid))
            {
                queryParams = AddParamsToQueryParams(queryParams, "toreleaseid", Toreleaseid);
            }
            var toreleasenumStringValue = Toreleasenum.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "toreleasenum", toreleasenumStringValue);
            if (queryParams.Count > 0)
            {
                PathAndQueryParams = $"{PathAndQueryParams}?{string.Join("&", queryParams)}";
            }
        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
            };

            string[] accepts = {
                "application/json",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "GET";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// GetReleaseDiffEntriesRequest
    /// Get changed entries between releases
    /// </summary>
    [Preserve]
    internal class GetReleaseDiffEntriesRequest : ReleasesApiBaseRequest
    {
        /// <summary>Accessor for bucketid </summary>
        [Preserve]
        public string Bucketid { get; }
        /// <summary>Accessor for projectid </summary>
        [Preserve]
        public string Projectid { get; }
        /// <summary>Accessor for fromreleaseid </summary>
        [Preserve]
        public string Fromreleaseid { get; }
        /// <summary>Accessor for fromreleasenum </summary>
        [Preserve]
        public int? Fromreleasenum { get; }
        /// <summary>Accessor for toreleaseid </summary>
        [Preserve]
        public string Toreleaseid { get; }
        /// <summary>Accessor for toreleasenum </summary>
        [Preserve]
        public int? Toreleasenum { get; }
        /// <summary>Accessor for page </summary>
        [Preserve]
        public int? Page { get; }
        /// <summary>Accessor for perPage </summary>
        [Preserve]
        public int? PerPage { get; }
        /// <summary>Accessor for path </summary>
        [Preserve]
        public string Path { get; }
        /// <summary>Accessor for includeStates </summary>
        [Preserve]
        public List<string> IncludeStates { get; }
        /// <summary>Accessor for contentType </summary>
        [Preserve]
        public string ContentType { get; }
        /// <summary>Accessor for label </summary>
        [Preserve]
        public string Label { get; }
        /// <summary>Accessor for complete </summary>
        [Preserve]
        public bool? Complete { get; }
        /// <summary>Accessor for sortBy </summary>
        [Preserve]
        public string SortBy { get; }
        /// <summary>Accessor for sortOrder </summary>
        [Preserve]
        public string SortOrder { get; }
        string PathAndQueryParams;

        /// <summary>
        /// GetReleaseDiffEntries Request Object.
        /// Get changed entries between releases
        /// </summary>
        /// <param name="bucketid">Bucket ID</param>
        /// <param name="projectid">Project ID</param>
        /// <param name="fromreleaseid">From Release ID, specify 'latest' to use the most recent release. Either fromreleaseid or fromreleasenum can be specified, but not both. </param>
        /// <param name="fromreleasenum">From Release Number. To query against an empty bucket you may set fromreleasenum to zero. Either fromreleaseid or fromreleasenum can be specified, but not both. </param>
        /// <param name="toreleaseid">To Release ID, when not specified the most recent state of the bucket will be used. Either toreleaseid or toreleasenum can be specified, but not both. </param>
        /// <param name="toreleasenum">To Release ID, when not specified the most recent state of the bucket will be used. Either toreleaseid or toreleasenum can be specified, but not both. </param>
        /// <param name="page">Current Page</param>
        /// <param name="perPage">Items Per Page</param>
        /// <param name="path">Path</param>
        /// <param name="includeStates">Include change states, one or more can be specified. The default is all states.</param>
        /// <param name="contentType">content type</param>
        /// <param name="label">Label</param>
        /// <param name="complete">is content upload completed or not</param>
        /// <param name="sortBy">Sort By</param>
        /// <param name="sortOrder">Sort Order</param>
        [Preserve]
        public GetReleaseDiffEntriesRequest(string bucketid, string projectid, string fromreleaseid = default(string), int? fromreleasenum = default(int?), string toreleaseid = default(string), int? toreleasenum = default(int?), int? page = default(int?), int? perPage = 10, string path = default(string), List<string> includeStates = default(List<string>), string contentType = default(string), string label = default(string), bool? complete = default(bool?), string sortBy = default(string), string sortOrder = default(string))
        {
            Bucketid = bucketid;

            Projectid = projectid;

            Fromreleaseid = fromreleaseid;
            Fromreleasenum = fromreleasenum;
            Toreleaseid = toreleaseid;
            Toreleasenum = toreleasenum;
            Page = page;
            PerPage = perPage;
            Path = path;
            IncludeStates = includeStates;
            ContentType = contentType;
            Label = label;
            Complete = complete;
            SortBy = sortBy;
            SortOrder = sortOrder;
            PathAndQueryParams = $"/api/ccd/management/v1/projects/{projectid}/buckets/{bucketid}/diff/releases/entries";

            List<string> queryParams = new List<string>();

            if(!string.IsNullOrEmpty(Fromreleaseid))
            {
                queryParams = AddParamsToQueryParams(queryParams, "fromreleaseid", Fromreleaseid);
            }
            var fromreleasenumStringValue = Fromreleasenum.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "fromreleasenum", fromreleasenumStringValue);
            if(!string.IsNullOrEmpty(Toreleaseid))
            {
                queryParams = AddParamsToQueryParams(queryParams, "toreleaseid", Toreleaseid);
            }
            var toreleasenumStringValue = Toreleasenum.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "toreleasenum", toreleasenumStringValue);
            var pageStringValue = Page.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "page", pageStringValue);
            var perPageStringValue = PerPage.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "per_page", perPageStringValue);
            if(!string.IsNullOrEmpty(Path))
            {
                queryParams = AddParamsToQueryParams(queryParams, "path", Path);
            }
            if(IncludeStates != null)
            {
                var includeStatesStringValues = IncludeStates.Select(v => v.ToString()).ToList();
                queryParams = AddParamsToQueryParams(queryParams, "include_states", includeStatesStringValues, "form", false);
            }
            if(!string.IsNullOrEmpty(ContentType))
            {
                queryParams = AddParamsToQueryParams(queryParams, "content_type", ContentType);
            }
            if(!string.IsNullOrEmpty(Label))
            {
                queryParams = AddParamsToQueryParams(queryParams, "label", Label);
            }
            var completeStringValue = Complete.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "complete", completeStringValue);
            if(!string.IsNullOrEmpty(SortBy))
            {
                queryParams = AddParamsToQueryParams(queryParams, "sort_by", SortBy);
            }
            if(!string.IsNullOrEmpty(SortOrder))
            {
                queryParams = AddParamsToQueryParams(queryParams, "sort_order", SortOrder);
            }
            if (queryParams.Count > 0)
            {
                PathAndQueryParams = $"{PathAndQueryParams}?{string.Join("&", queryParams)}";
            }
        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
            };

            string[] accepts = {
                "application/json",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "GET";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// GetReleaseDiffEntriesEnvRequest
    /// Get changed entries between releases
    /// </summary>
    [Preserve]
    internal class GetReleaseDiffEntriesEnvRequest : ReleasesApiBaseRequest
    {
        /// <summary>Accessor for environmentid </summary>
        [Preserve]
        public string Environmentid { get; }
        /// <summary>Accessor for bucketid </summary>
        [Preserve]
        public string Bucketid { get; }
        /// <summary>Accessor for projectid </summary>
        [Preserve]
        public string Projectid { get; }
        /// <summary>Accessor for fromreleaseid </summary>
        [Preserve]
        public string Fromreleaseid { get; }
        /// <summary>Accessor for fromreleasenum </summary>
        [Preserve]
        public string Fromreleasenum { get; }
        /// <summary>Accessor for toreleaseid </summary>
        [Preserve]
        public string Toreleaseid { get; }
        /// <summary>Accessor for toreleasenum </summary>
        [Preserve]
        public string Toreleasenum { get; }
        /// <summary>Accessor for page </summary>
        [Preserve]
        public int? Page { get; }
        /// <summary>Accessor for perPage </summary>
        [Preserve]
        public int? PerPage { get; }
        /// <summary>Accessor for path </summary>
        [Preserve]
        public string Path { get; }
        /// <summary>Accessor for includeStates </summary>
        [Preserve]
        public List<string> IncludeStates { get; }
        /// <summary>Accessor for contentType </summary>
        [Preserve]
        public string ContentType { get; }
        /// <summary>Accessor for label </summary>
        [Preserve]
        public string Label { get; }
        /// <summary>Accessor for complete </summary>
        [Preserve]
        public bool? Complete { get; }
        /// <summary>Accessor for sortBy </summary>
        [Preserve]
        public string SortBy { get; }
        /// <summary>Accessor for sortOrder </summary>
        [Preserve]
        public string SortOrder { get; }
        string PathAndQueryParams;

        /// <summary>
        /// GetReleaseDiffEntriesEnv Request Object.
        /// Get changed entries between releases
        /// </summary>
        /// <param name="environmentid">Environment ID</param>
        /// <param name="bucketid">Bucket ID</param>
        /// <param name="projectid">Project ID</param>
        /// <param name="fromreleaseid">From Release ID, specify 'latest' to use the most recent release. Either fromreleaseid or fromreleasenum can be specified, but not both. </param>
        /// <param name="fromreleasenum">From Release Number. To query against an empty bucket you may set fromreleasenum to zero. Either fromreleaseid or fromreleasenum can be specified, but not both. </param>
        /// <param name="toreleaseid">To Release ID, when not specified the most recent state of the bucket will be used. Either toreleaseid or toreleasenum can be specified, but not both. </param>
        /// <param name="toreleasenum">To Release ID, when not specified the most recent state of the bucket will be used. Either toreleaseid or toreleasenum can be specified, but not both. </param>
        /// <param name="page">Current Page</param>
        /// <param name="perPage">Items Per Page</param>
        /// <param name="path">Path</param>
        /// <param name="includeStates">Include change states, one or more can be specified. The default is all states.</param>
        /// <param name="contentType">content type</param>
        /// <param name="label">Label</param>
        /// <param name="complete">is content upload completed or not</param>
        /// <param name="sortBy">Sort By</param>
        /// <param name="sortOrder">Sort Order</param>
        [Preserve]
        public GetReleaseDiffEntriesEnvRequest(string environmentid, string bucketid, string projectid, string fromreleaseid = default(string), string fromreleasenum = default(string), string toreleaseid = default(string), string toreleasenum = default(string), int? page = default(int?), int? perPage = 10, string path = default(string), List<string> includeStates = default(List<string>), string contentType = default(string), string label = default(string), bool? complete = default(bool?), string sortBy = default(string), string sortOrder = default(string))
        {
            Environmentid = environmentid;

            Bucketid = bucketid;

            Projectid = projectid;

            Fromreleaseid = fromreleaseid;
            Fromreleasenum = fromreleasenum;
            Toreleaseid = toreleaseid;
            Toreleasenum = toreleasenum;
            Page = page;
            PerPage = perPage;
            Path = path;
            IncludeStates = includeStates;
            ContentType = contentType;
            Label = label;
            Complete = complete;
            SortBy = sortBy;
            SortOrder = sortOrder;
            PathAndQueryParams = $"/api/ccd/management/v1/projects/{projectid}/environments/{environmentid}/buckets/{bucketid}/diff/releases/entries";

            List<string> queryParams = new List<string>();

            if(!string.IsNullOrEmpty(Fromreleaseid))
            {
                queryParams = AddParamsToQueryParams(queryParams, "fromreleaseid", Fromreleaseid);
            }
            if(!string.IsNullOrEmpty(Fromreleasenum))
            {
                queryParams = AddParamsToQueryParams(queryParams, "fromreleasenum", Fromreleasenum);
            }
            if(!string.IsNullOrEmpty(Toreleaseid))
            {
                queryParams = AddParamsToQueryParams(queryParams, "toreleaseid", Toreleaseid);
            }
            if(!string.IsNullOrEmpty(Toreleasenum))
            {
                queryParams = AddParamsToQueryParams(queryParams, "toreleasenum", Toreleasenum);
            }
            var pageStringValue = Page.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "page", pageStringValue);
            var perPageStringValue = PerPage.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "per_page", perPageStringValue);
            if(!string.IsNullOrEmpty(Path))
            {
                queryParams = AddParamsToQueryParams(queryParams, "path", Path);
            }
            if(IncludeStates != null)
            {
                var includeStatesStringValues = IncludeStates.Select(v => v.ToString()).ToList();
                queryParams = AddParamsToQueryParams(queryParams, "include_states", includeStatesStringValues, "form", false);
            }
            if(!string.IsNullOrEmpty(ContentType))
            {
                queryParams = AddParamsToQueryParams(queryParams, "content_type", ContentType);
            }
            if(!string.IsNullOrEmpty(Label))
            {
                queryParams = AddParamsToQueryParams(queryParams, "label", Label);
            }
            var completeStringValue = Complete.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "complete", completeStringValue);
            if(!string.IsNullOrEmpty(SortBy))
            {
                queryParams = AddParamsToQueryParams(queryParams, "sort_by", SortBy);
            }
            if(!string.IsNullOrEmpty(SortOrder))
            {
                queryParams = AddParamsToQueryParams(queryParams, "sort_order", SortOrder);
            }
            if (queryParams.Count > 0)
            {
                PathAndQueryParams = $"{PathAndQueryParams}?{string.Join("&", queryParams)}";
            }
        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
            };

            string[] accepts = {
                "application/json",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "GET";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// GetReleaseDiffEnvRequest
    /// Get counts of changes between releases
    /// </summary>
    [Preserve]
    internal class GetReleaseDiffEnvRequest : ReleasesApiBaseRequest
    {
        /// <summary>Accessor for environmentid </summary>
        [Preserve]
        public string Environmentid { get; }
        /// <summary>Accessor for bucketid </summary>
        [Preserve]
        public string Bucketid { get; }
        /// <summary>Accessor for projectid </summary>
        [Preserve]
        public string Projectid { get; }
        /// <summary>Accessor for fromreleaseid </summary>
        [Preserve]
        public string Fromreleaseid { get; }
        /// <summary>Accessor for fromreleasenum </summary>
        [Preserve]
        public string Fromreleasenum { get; }
        /// <summary>Accessor for toreleaseid </summary>
        [Preserve]
        public string Toreleaseid { get; }
        /// <summary>Accessor for toreleasenum </summary>
        [Preserve]
        public string Toreleasenum { get; }
        string PathAndQueryParams;

        /// <summary>
        /// GetReleaseDiffEnv Request Object.
        /// Get counts of changes between releases
        /// </summary>
        /// <param name="environmentid">Environment ID</param>
        /// <param name="bucketid">Bucket ID</param>
        /// <param name="projectid">Project ID</param>
        /// <param name="fromreleaseid">From Release ID, specify 'latest' to use the most recent release. Either fromreleaseid or fromreleasenum can be specified, but not both. </param>
        /// <param name="fromreleasenum">From Release Number. To query against an empty bucket you may set fromreleasenum to zero. Either fromreleaseid or fromreleasenum can be specified, but not both. </param>
        /// <param name="toreleaseid">To Release ID, when not specified the most recent state of the bucket will be used. Either toreleaseid or toreleasenum can be specified, but not both. </param>
        /// <param name="toreleasenum">To Release ID, when not specified the most recent state of the bucket will be used. Either toreleaseid or toreleasenum can be specified, but not both. </param>
        [Preserve]
        public GetReleaseDiffEnvRequest(string environmentid, string bucketid, string projectid, string fromreleaseid = default(string), string fromreleasenum = default(string), string toreleaseid = default(string), string toreleasenum = default(string))
        {
            Environmentid = environmentid;

            Bucketid = bucketid;

            Projectid = projectid;

            Fromreleaseid = fromreleaseid;
            Fromreleasenum = fromreleasenum;
            Toreleaseid = toreleaseid;
            Toreleasenum = toreleasenum;
            PathAndQueryParams = $"/api/ccd/management/v1/projects/{projectid}/environments/{environmentid}/buckets/{bucketid}/diff/releases";

            List<string> queryParams = new List<string>();

            if(!string.IsNullOrEmpty(Fromreleaseid))
            {
                queryParams = AddParamsToQueryParams(queryParams, "fromreleaseid", Fromreleaseid);
            }
            if(!string.IsNullOrEmpty(Fromreleasenum))
            {
                queryParams = AddParamsToQueryParams(queryParams, "fromreleasenum", Fromreleasenum);
            }
            if(!string.IsNullOrEmpty(Toreleaseid))
            {
                queryParams = AddParamsToQueryParams(queryParams, "toreleaseid", Toreleaseid);
            }
            if(!string.IsNullOrEmpty(Toreleasenum))
            {
                queryParams = AddParamsToQueryParams(queryParams, "toreleasenum", Toreleasenum);
            }
            if (queryParams.Count > 0)
            {
                PathAndQueryParams = $"{PathAndQueryParams}?{string.Join("&", queryParams)}";
            }
        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
            };

            string[] accepts = {
                "application/json",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "GET";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// GetReleaseEntriesRequest
    /// Get release entries
    /// </summary>
    [Preserve]
    internal class GetReleaseEntriesRequest : ReleasesApiBaseRequest
    {
        /// <summary>Accessor for bucketid </summary>
        [Preserve]
        public string Bucketid { get; }
        /// <summary>Accessor for releaseid </summary>
        [Preserve]
        public string Releaseid { get; }
        /// <summary>Accessor for projectid </summary>
        [Preserve]
        public string Projectid { get; }
        /// <summary>Accessor for label </summary>
        [Preserve]
        public string Label { get; }
        /// <summary>Accessor for page </summary>
        [Preserve]
        public int? Page { get; }
        /// <summary>Accessor for perPage </summary>
        [Preserve]
        public int? PerPage { get; }
        string PathAndQueryParams;

        /// <summary>
        /// GetReleaseEntries Request Object.
        /// Get release entries
        /// </summary>
        /// <param name="bucketid">Bucket ID</param>
        /// <param name="releaseid">Release ID</param>
        /// <param name="projectid">Project ID</param>
        /// <param name="label">Label</param>
        /// <param name="page">Current Page</param>
        /// <param name="perPage">Items Per Page</param>
        [Preserve]
        public GetReleaseEntriesRequest(string bucketid, string releaseid, string projectid, string label = default(string), int? page = default(int?), int? perPage = 10)
        {
            Bucketid = bucketid;

            Releaseid = releaseid;

            Projectid = projectid;

            Label = label;
            Page = page;
            PerPage = perPage;
            PathAndQueryParams = $"/api/ccd/management/v1/projects/{projectid}/buckets/{bucketid}/releases/{releaseid}/entries";

            List<string> queryParams = new List<string>();

            if(!string.IsNullOrEmpty(Label))
            {
                queryParams = AddParamsToQueryParams(queryParams, "label", Label);
            }
            var pageStringValue = Page.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "page", pageStringValue);
            var perPageStringValue = PerPage.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "per_page", perPageStringValue);
            if (queryParams.Count > 0)
            {
                PathAndQueryParams = $"{PathAndQueryParams}?{string.Join("&", queryParams)}";
            }
        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
            };

            string[] accepts = {
                "application/json",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "GET";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// GetReleaseEntriesByBadgeRequest
    /// Get badged release entries
    /// </summary>
    [Preserve]
    internal class GetReleaseEntriesByBadgeRequest : ReleasesApiBaseRequest
    {
        /// <summary>Accessor for bucketid </summary>
        [Preserve]
        public string Bucketid { get; }
        /// <summary>Accessor for badgename </summary>
        [Preserve]
        public string Badgename { get; }
        /// <summary>Accessor for projectid </summary>
        [Preserve]
        public string Projectid { get; }
        /// <summary>Accessor for label </summary>
        [Preserve]
        public string Label { get; }
        /// <summary>Accessor for page </summary>
        [Preserve]
        public int? Page { get; }
        /// <summary>Accessor for perPage </summary>
        [Preserve]
        public int? PerPage { get; }
        string PathAndQueryParams;

        /// <summary>
        /// GetReleaseEntriesByBadge Request Object.
        /// Get badged release entries
        /// </summary>
        /// <param name="bucketid">Bucket ID</param>
        /// <param name="badgename">Badge Name</param>
        /// <param name="projectid">Project ID</param>
        /// <param name="label">Label</param>
        /// <param name="page">Current Page</param>
        /// <param name="perPage">Items Per Page</param>
        [Preserve]
        public GetReleaseEntriesByBadgeRequest(string bucketid, string badgename, string projectid, string label = default(string), int? page = default(int?), int? perPage = 10)
        {
            Bucketid = bucketid;

            Badgename = badgename;

            Projectid = projectid;

            Label = label;
            Page = page;
            PerPage = perPage;
            PathAndQueryParams = $"/api/ccd/management/v1/projects/{projectid}/buckets/{bucketid}/release_by_badge/{badgename}/entries";

            List<string> queryParams = new List<string>();

            if(!string.IsNullOrEmpty(Label))
            {
                queryParams = AddParamsToQueryParams(queryParams, "label", Label);
            }
            var pageStringValue = Page.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "page", pageStringValue);
            var perPageStringValue = PerPage.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "per_page", perPageStringValue);
            if (queryParams.Count > 0)
            {
                PathAndQueryParams = $"{PathAndQueryParams}?{string.Join("&", queryParams)}";
            }
        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
            };

            string[] accepts = {
                "application/json",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "GET";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// GetReleaseEntriesByBadgeEnvRequest
    /// Get badged release entries
    /// </summary>
    [Preserve]
    internal class GetReleaseEntriesByBadgeEnvRequest : ReleasesApiBaseRequest
    {
        /// <summary>Accessor for environmentid </summary>
        [Preserve]
        public string Environmentid { get; }
        /// <summary>Accessor for bucketid </summary>
        [Preserve]
        public string Bucketid { get; }
        /// <summary>Accessor for badgename </summary>
        [Preserve]
        public string Badgename { get; }
        /// <summary>Accessor for projectid </summary>
        [Preserve]
        public string Projectid { get; }
        /// <summary>Accessor for label </summary>
        [Preserve]
        public string Label { get; }
        /// <summary>Accessor for page </summary>
        [Preserve]
        public int? Page { get; }
        /// <summary>Accessor for perPage </summary>
        [Preserve]
        public int? PerPage { get; }
        string PathAndQueryParams;

        /// <summary>
        /// GetReleaseEntriesByBadgeEnv Request Object.
        /// Get badged release entries
        /// </summary>
        /// <param name="environmentid">Environment ID</param>
        /// <param name="bucketid">Bucket ID</param>
        /// <param name="badgename">Badge Name</param>
        /// <param name="projectid">Project ID</param>
        /// <param name="label">Label</param>
        /// <param name="page">Current Page</param>
        /// <param name="perPage">Items Per Page</param>
        [Preserve]
        public GetReleaseEntriesByBadgeEnvRequest(string environmentid, string bucketid, string badgename, string projectid, string label = default(string), int? page = default(int?), int? perPage = 10)
        {
            Environmentid = environmentid;

            Bucketid = bucketid;

            Badgename = badgename;

            Projectid = projectid;

            Label = label;
            Page = page;
            PerPage = perPage;
            PathAndQueryParams = $"/api/ccd/management/v1/projects/{projectid}/environments/{environmentid}/buckets/{bucketid}/release_by_badge/{badgename}/entries";

            List<string> queryParams = new List<string>();

            if(!string.IsNullOrEmpty(Label))
            {
                queryParams = AddParamsToQueryParams(queryParams, "label", Label);
            }
            var pageStringValue = Page.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "page", pageStringValue);
            var perPageStringValue = PerPage.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "per_page", perPageStringValue);
            if (queryParams.Count > 0)
            {
                PathAndQueryParams = $"{PathAndQueryParams}?{string.Join("&", queryParams)}";
            }
        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
            };

            string[] accepts = {
                "application/json",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "GET";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// GetReleaseEntriesEnvRequest
    /// Get release entries
    /// </summary>
    [Preserve]
    internal class GetReleaseEntriesEnvRequest : ReleasesApiBaseRequest
    {
        /// <summary>Accessor for environmentid </summary>
        [Preserve]
        public string Environmentid { get; }
        /// <summary>Accessor for bucketid </summary>
        [Preserve]
        public string Bucketid { get; }
        /// <summary>Accessor for releaseid </summary>
        [Preserve]
        public string Releaseid { get; }
        /// <summary>Accessor for projectid </summary>
        [Preserve]
        public string Projectid { get; }
        /// <summary>Accessor for label </summary>
        [Preserve]
        public string Label { get; }
        /// <summary>Accessor for page </summary>
        [Preserve]
        public int? Page { get; }
        /// <summary>Accessor for perPage </summary>
        [Preserve]
        public int? PerPage { get; }
        string PathAndQueryParams;

        /// <summary>
        /// GetReleaseEntriesEnv Request Object.
        /// Get release entries
        /// </summary>
        /// <param name="environmentid">Environment ID</param>
        /// <param name="bucketid">Bucket ID</param>
        /// <param name="releaseid">Release ID</param>
        /// <param name="projectid">Project ID</param>
        /// <param name="label">Label</param>
        /// <param name="page">Current Page</param>
        /// <param name="perPage">Items Per Page</param>
        [Preserve]
        public GetReleaseEntriesEnvRequest(string environmentid, string bucketid, string releaseid, string projectid, string label = default(string), int? page = default(int?), int? perPage = 10)
        {
            Environmentid = environmentid;

            Bucketid = bucketid;

            Releaseid = releaseid;

            Projectid = projectid;

            Label = label;
            Page = page;
            PerPage = perPage;
            PathAndQueryParams = $"/api/ccd/management/v1/projects/{projectid}/environments/{environmentid}/buckets/{bucketid}/releases/{releaseid}/entries";

            List<string> queryParams = new List<string>();

            if(!string.IsNullOrEmpty(Label))
            {
                queryParams = AddParamsToQueryParams(queryParams, "label", Label);
            }
            var pageStringValue = Page.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "page", pageStringValue);
            var perPageStringValue = PerPage.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "per_page", perPageStringValue);
            if (queryParams.Count > 0)
            {
                PathAndQueryParams = $"{PathAndQueryParams}?{string.Join("&", queryParams)}";
            }
        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
            };

            string[] accepts = {
                "application/json",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "GET";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// GetReleaseEnvRequest
    /// Get release
    /// </summary>
    [Preserve]
    internal class GetReleaseEnvRequest : ReleasesApiBaseRequest
    {
        /// <summary>Accessor for environmentid </summary>
        [Preserve]
        public string Environmentid { get; }
        /// <summary>Accessor for bucketid </summary>
        [Preserve]
        public string Bucketid { get; }
        /// <summary>Accessor for releaseid </summary>
        [Preserve]
        public string Releaseid { get; }
        /// <summary>Accessor for projectid </summary>
        [Preserve]
        public string Projectid { get; }
        string PathAndQueryParams;

        /// <summary>
        /// GetReleaseEnv Request Object.
        /// Get release
        /// </summary>
        /// <param name="environmentid">Environment ID</param>
        /// <param name="bucketid">Bucket ID</param>
        /// <param name="releaseid">Release ID</param>
        /// <param name="projectid">Project ID</param>
        [Preserve]
        public GetReleaseEnvRequest(string environmentid, string bucketid, string releaseid, string projectid)
        {
            Environmentid = environmentid;

            Bucketid = bucketid;

            Releaseid = releaseid;

            Projectid = projectid;

            PathAndQueryParams = $"/api/ccd/management/v1/projects/{projectid}/environments/{environmentid}/buckets/{bucketid}/releases/{releaseid}";


        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
            };

            string[] accepts = {
                "application/json",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "GET";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// GetReleasesRequest
    /// Get releases for bucket
    /// </summary>
    [Preserve]
    internal class GetReleasesRequest : ReleasesApiBaseRequest
    {
        /// <summary>Accessor for bucketid </summary>
        [Preserve]
        public string Bucketid { get; }
        /// <summary>Accessor for projectid </summary>
        [Preserve]
        public string Projectid { get; }
        /// <summary>Accessor for page </summary>
        [Preserve]
        public int? Page { get; }
        /// <summary>Accessor for perPage </summary>
        [Preserve]
        public int? PerPage { get; }
        /// <summary>Accessor for releasenum </summary>
        [Preserve]
        public string Releasenum { get; }
        /// <summary>Accessor for notes </summary>
        [Preserve]
        public string Notes { get; }
        /// <summary>Accessor for promotedFromBucket </summary>
        [Preserve]
        public string PromotedFromBucket { get; }
        /// <summary>Accessor for promotedFromRelease </summary>
        [Preserve]
        public string PromotedFromRelease { get; }
        /// <summary>Accessor for badges </summary>
        [Preserve]
        public string Badges { get; }
        /// <summary>Accessor for sortBy </summary>
        [Preserve]
        public string SortBy { get; }
        /// <summary>Accessor for sortOrder </summary>
        [Preserve]
        public string SortOrder { get; }
        string PathAndQueryParams;

        /// <summary>
        /// GetReleases Request Object.
        /// Get releases for bucket
        /// </summary>
        /// <param name="bucketid">Bucket ID</param>
        /// <param name="projectid">Project ID</param>
        /// <param name="page">Current Page</param>
        /// <param name="perPage">Items Per Page</param>
        /// <param name="releasenum">release number</param>
        /// <param name="notes">Release notes </param>
        /// <param name="promotedFromBucket">Bucket where release promoted from. </param>
        /// <param name="promotedFromRelease">Release where release promoted from. </param>
        /// <param name="badges">Badge names. </param>
        /// <param name="sortBy">Sort By</param>
        /// <param name="sortOrder">Sort Order</param>
        [Preserve]
        public GetReleasesRequest(string bucketid, string projectid, int? page = default(int?), int? perPage = 10, string releasenum = default(string), string notes = default(string), string promotedFromBucket = default(string), string promotedFromRelease = default(string), string badges = default(string), string sortBy = default(string), string sortOrder = default(string))
        {
            Bucketid = bucketid;

            Projectid = projectid;

            Page = page;
            PerPage = perPage;
            Releasenum = releasenum;
            Notes = notes;
            PromotedFromBucket = promotedFromBucket;
            PromotedFromRelease = promotedFromRelease;
            Badges = badges;
            SortBy = sortBy;
            SortOrder = sortOrder;
            PathAndQueryParams = $"/api/ccd/management/v1/projects/{projectid}/buckets/{bucketid}/releases";

            List<string> queryParams = new List<string>();

            var pageStringValue = Page.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "page", pageStringValue);
            var perPageStringValue = PerPage.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "per_page", perPageStringValue);
            if(!string.IsNullOrEmpty(Releasenum))
            {
                queryParams = AddParamsToQueryParams(queryParams, "releasenum", Releasenum);
            }
            if(!string.IsNullOrEmpty(Notes))
            {
                queryParams = AddParamsToQueryParams(queryParams, "notes", Notes);
            }
            if(!string.IsNullOrEmpty(PromotedFromBucket))
            {
                queryParams = AddParamsToQueryParams(queryParams, "promoted_from_bucket", PromotedFromBucket);
            }
            if(!string.IsNullOrEmpty(PromotedFromRelease))
            {
                queryParams = AddParamsToQueryParams(queryParams, "promoted_from_release", PromotedFromRelease);
            }
            if(!string.IsNullOrEmpty(Badges))
            {
                queryParams = AddParamsToQueryParams(queryParams, "badges", Badges);
            }
            if(!string.IsNullOrEmpty(SortBy))
            {
                queryParams = AddParamsToQueryParams(queryParams, "sort_by", SortBy);
            }
            if(!string.IsNullOrEmpty(SortOrder))
            {
                queryParams = AddParamsToQueryParams(queryParams, "sort_order", SortOrder);
            }
            if (queryParams.Count > 0)
            {
                PathAndQueryParams = $"{PathAndQueryParams}?{string.Join("&", queryParams)}";
            }
        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
            };

            string[] accepts = {
                "application/json",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "GET";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// GetReleasesEnvRequest
    /// Get releases for bucket
    /// </summary>
    [Preserve]
    internal class GetReleasesEnvRequest : ReleasesApiBaseRequest
    {
        /// <summary>Accessor for environmentid </summary>
        [Preserve]
        public string Environmentid { get; }
        /// <summary>Accessor for bucketid </summary>
        [Preserve]
        public string Bucketid { get; }
        /// <summary>Accessor for projectid </summary>
        [Preserve]
        public string Projectid { get; }
        /// <summary>Accessor for page </summary>
        [Preserve]
        public int? Page { get; }
        /// <summary>Accessor for perPage </summary>
        [Preserve]
        public int? PerPage { get; }
        /// <summary>Accessor for releasenum </summary>
        [Preserve]
        public string Releasenum { get; }
        /// <summary>Accessor for notes </summary>
        [Preserve]
        public string Notes { get; }
        /// <summary>Accessor for promotedFromBucket </summary>
        [Preserve]
        public string PromotedFromBucket { get; }
        /// <summary>Accessor for promotedFromRelease </summary>
        [Preserve]
        public string PromotedFromRelease { get; }
        /// <summary>Accessor for badges </summary>
        [Preserve]
        public string Badges { get; }
        /// <summary>Accessor for sortBy </summary>
        [Preserve]
        public string SortBy { get; }
        /// <summary>Accessor for sortOrder </summary>
        [Preserve]
        public string SortOrder { get; }
        string PathAndQueryParams;

        /// <summary>
        /// GetReleasesEnv Request Object.
        /// Get releases for bucket
        /// </summary>
        /// <param name="environmentid">Environment ID</param>
        /// <param name="bucketid">Bucket ID</param>
        /// <param name="projectid">Project ID</param>
        /// <param name="page">Current Page</param>
        /// <param name="perPage">Items Per Page</param>
        /// <param name="releasenum">release number</param>
        /// <param name="notes">Release notes </param>
        /// <param name="promotedFromBucket">Bucket where release promoted from. </param>
        /// <param name="promotedFromRelease">Release where release promoted from. </param>
        /// <param name="badges">Badge names. </param>
        /// <param name="sortBy">Sort By</param>
        /// <param name="sortOrder">Sort Order</param>
        [Preserve]
        public GetReleasesEnvRequest(string environmentid, string bucketid, string projectid, int? page = default(int?), int? perPage = 10, string releasenum = default(string), string notes = default(string), string promotedFromBucket = default(string), string promotedFromRelease = default(string), string badges = default(string), string sortBy = default(string), string sortOrder = default(string))
        {
            Environmentid = environmentid;

            Bucketid = bucketid;

            Projectid = projectid;

            Page = page;
            PerPage = perPage;
            Releasenum = releasenum;
            Notes = notes;
            PromotedFromBucket = promotedFromBucket;
            PromotedFromRelease = promotedFromRelease;
            Badges = badges;
            SortBy = sortBy;
            SortOrder = sortOrder;
            PathAndQueryParams = $"/api/ccd/management/v1/projects/{projectid}/environments/{environmentid}/buckets/{bucketid}/releases";

            List<string> queryParams = new List<string>();

            var pageStringValue = Page.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "page", pageStringValue);
            var perPageStringValue = PerPage.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "per_page", perPageStringValue);
            if(!string.IsNullOrEmpty(Releasenum))
            {
                queryParams = AddParamsToQueryParams(queryParams, "releasenum", Releasenum);
            }
            if(!string.IsNullOrEmpty(Notes))
            {
                queryParams = AddParamsToQueryParams(queryParams, "notes", Notes);
            }
            if(!string.IsNullOrEmpty(PromotedFromBucket))
            {
                queryParams = AddParamsToQueryParams(queryParams, "promoted_from_bucket", PromotedFromBucket);
            }
            if(!string.IsNullOrEmpty(PromotedFromRelease))
            {
                queryParams = AddParamsToQueryParams(queryParams, "promoted_from_release", PromotedFromRelease);
            }
            if(!string.IsNullOrEmpty(Badges))
            {
                queryParams = AddParamsToQueryParams(queryParams, "badges", Badges);
            }
            if(!string.IsNullOrEmpty(SortBy))
            {
                queryParams = AddParamsToQueryParams(queryParams, "sort_by", SortBy);
            }
            if(!string.IsNullOrEmpty(SortOrder))
            {
                queryParams = AddParamsToQueryParams(queryParams, "sort_order", SortOrder);
            }
            if (queryParams.Count > 0)
            {
                PathAndQueryParams = $"{PathAndQueryParams}?{string.Join("&", queryParams)}";
            }
        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
            };

            string[] accepts = {
                "application/json",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "GET";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// GetStatsRequest
    /// Get stats for a release
    /// </summary>
    [Preserve]
    internal class GetStatsRequest : ReleasesApiBaseRequest
    {
        /// <summary>Accessor for bucketid </summary>
        [Preserve]
        public string Bucketid { get; }
        /// <summary>Accessor for releaseid </summary>
        [Preserve]
        public string Releaseid { get; }
        /// <summary>Accessor for metric </summary>
        [Preserve]
        public string Metric { get; }
        /// <summary>Accessor for interval </summary>
        [Preserve]
        public string Interval { get; }
        /// <summary>Accessor for projectid </summary>
        [Preserve]
        public string Projectid { get; }
        string PathAndQueryParams;

        /// <summary>
        /// GetStats Request Object.
        /// Get stats for a release
        /// </summary>
        /// <param name="bucketid">Bucket ID</param>
        /// <param name="releaseid">Release ID</param>
        /// <param name="metric">Select the metric for which you want the stats.</param>
        /// <param name="interval">Select the time interval for which you want the stats. day indicates last 24 hrs week indicates last 7 days month indicates last 30 days </param>
        /// <param name="projectid">Project ID</param>
        [Preserve]
        public GetStatsRequest(string bucketid, string releaseid, string metric, string interval, string projectid)
        {
            Bucketid = bucketid;

            Releaseid = releaseid;

            Metric = metric;
            Interval = interval;
            Projectid = projectid;

            PathAndQueryParams = $"/api/ccd/management/v1/projects/{projectid}/buckets/{bucketid}/releases/{releaseid}/stats";

            List<string> queryParams = new List<string>();

            if(!string.IsNullOrEmpty(Metric))
            {
                queryParams = AddParamsToQueryParams(queryParams, "metric", Metric);
            }
            if(!string.IsNullOrEmpty(Interval))
            {
                queryParams = AddParamsToQueryParams(queryParams, "interval", Interval);
            }
            if (queryParams.Count > 0)
            {
                PathAndQueryParams = $"{PathAndQueryParams}?{string.Join("&", queryParams)}";
            }
        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
            };

            string[] accepts = {
                "application/json",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "GET";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// GetStatsEnvRequest
    /// Get stats for a release
    /// </summary>
    [Preserve]
    internal class GetStatsEnvRequest : ReleasesApiBaseRequest
    {
        /// <summary>Accessor for environmentid </summary>
        [Preserve]
        public string Environmentid { get; }
        /// <summary>Accessor for bucketid </summary>
        [Preserve]
        public string Bucketid { get; }
        /// <summary>Accessor for releaseid </summary>
        [Preserve]
        public string Releaseid { get; }
        /// <summary>Accessor for metric </summary>
        [Preserve]
        public string Metric { get; }
        /// <summary>Accessor for interval </summary>
        [Preserve]
        public string Interval { get; }
        /// <summary>Accessor for projectid </summary>
        [Preserve]
        public string Projectid { get; }
        string PathAndQueryParams;

        /// <summary>
        /// GetStatsEnv Request Object.
        /// Get stats for a release
        /// </summary>
        /// <param name="environmentid">Environment ID</param>
        /// <param name="bucketid">Bucket ID</param>
        /// <param name="releaseid">Release ID</param>
        /// <param name="metric">Select the metric for which you want the stats.</param>
        /// <param name="interval">Select the time interval for which you want the stats. day indicates last 24 hrs week indicates last 7 days month indicates last 30 days </param>
        /// <param name="projectid">Project ID</param>
        [Preserve]
        public GetStatsEnvRequest(string environmentid, string bucketid, string releaseid, string metric, string interval, string projectid)
        {
            Environmentid = environmentid;

            Bucketid = bucketid;

            Releaseid = releaseid;

            Metric = metric;
            Interval = interval;
            Projectid = projectid;

            PathAndQueryParams = $"/api/ccd/management/v1/projects/{projectid}/environments/{environmentid}/buckets/{bucketid}/releases/{releaseid}/stats";

            List<string> queryParams = new List<string>();

            if(!string.IsNullOrEmpty(Metric))
            {
                queryParams = AddParamsToQueryParams(queryParams, "metric", Metric);
            }
            if(!string.IsNullOrEmpty(Interval))
            {
                queryParams = AddParamsToQueryParams(queryParams, "interval", Interval);
            }
            if (queryParams.Count > 0)
            {
                PathAndQueryParams = $"{PathAndQueryParams}?{string.Join("&", queryParams)}";
            }
        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
            };

            string[] accepts = {
                "application/json",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "GET";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// UpdateReleaseRequest
    /// Update release
    /// </summary>
    [Preserve]
    internal class UpdateReleaseRequest : ReleasesApiBaseRequest
    {
        /// <summary>Accessor for bucketid </summary>
        [Preserve]
        public string Bucketid { get; }
        /// <summary>Accessor for releaseid </summary>
        [Preserve]
        public string Releaseid { get; }
        /// <summary>Accessor for projectid </summary>
        [Preserve]
        public string Projectid { get; }
        /// <summary>Accessor for ccdReleaseUpdate </summary>
        [Preserve]
        public Unity.Services.Ccd.Management.Models.CcdReleaseUpdate CcdReleaseUpdate { get; }
        string PathAndQueryParams;

        /// <summary>
        /// UpdateRelease Request Object.
        /// Update release
        /// </summary>
        /// <param name="bucketid">Bucket ID</param>
        /// <param name="releaseid">Release ID</param>
        /// <param name="projectid">Project ID</param>
        /// <param name="ccdReleaseUpdate">Release fields to update</param>
        [Preserve]
        public UpdateReleaseRequest(string bucketid, string releaseid, string projectid, Unity.Services.Ccd.Management.Models.CcdReleaseUpdate ccdReleaseUpdate)
        {
            Bucketid = bucketid;

            Releaseid = releaseid;

            Projectid = projectid;

            CcdReleaseUpdate = ccdReleaseUpdate;
            PathAndQueryParams = $"/api/ccd/management/v1/projects/{projectid}/buckets/{bucketid}/releases/{releaseid}";


        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return ConstructBody(CcdReleaseUpdate);
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
                "application/json"
            };

            string[] accepts = {
                "application/json",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "PUT";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// UpdateReleaseEnvRequest
    /// Update release
    /// </summary>
    [Preserve]
    internal class UpdateReleaseEnvRequest : ReleasesApiBaseRequest
    {
        /// <summary>Accessor for environmentid </summary>
        [Preserve]
        public string Environmentid { get; }
        /// <summary>Accessor for bucketid </summary>
        [Preserve]
        public string Bucketid { get; }
        /// <summary>Accessor for releaseid </summary>
        [Preserve]
        public string Releaseid { get; }
        /// <summary>Accessor for projectid </summary>
        [Preserve]
        public string Projectid { get; }
        /// <summary>Accessor for ccdReleaseUpdate </summary>
        [Preserve]
        public Unity.Services.Ccd.Management.Models.CcdReleaseUpdate CcdReleaseUpdate { get; }
        string PathAndQueryParams;

        /// <summary>
        /// UpdateReleaseEnv Request Object.
        /// Update release
        /// </summary>
        /// <param name="environmentid">Environment ID</param>
        /// <param name="bucketid">Bucket ID</param>
        /// <param name="releaseid">Release ID</param>
        /// <param name="projectid">Project ID</param>
        /// <param name="ccdReleaseUpdate">Release fields to update</param>
        [Preserve]
        public UpdateReleaseEnvRequest(string environmentid, string bucketid, string releaseid, string projectid, Unity.Services.Ccd.Management.Models.CcdReleaseUpdate ccdReleaseUpdate)
        {
            Environmentid = environmentid;

            Bucketid = bucketid;

            Releaseid = releaseid;

            Projectid = projectid;

            CcdReleaseUpdate = ccdReleaseUpdate;
            PathAndQueryParams = $"/api/ccd/management/v1/projects/{projectid}/environments/{environmentid}/buckets/{bucketid}/releases/{releaseid}";


        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return ConstructBody(CcdReleaseUpdate);
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
                "application/json"
            };

            string[] accepts = {
                "application/json",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "PUT";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
}
